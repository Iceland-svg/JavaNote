## 1 进程和线程的区别

==从四个方面讲解

## 1.1角色不同
进程是==资源分配的基本单位==，具有自己独立的地址，而线程是==cpu调度的执行的基本单位==，是进程内部的一个执行流线程共用进程的资源，二者类似于厨房和多个厨师的关系。

## 1.2资源开销不同
正因为进程的独立，==进程在创建，销毁，切换上下文（在不同进程中切换）的过程中都有比较大的开销==，而线程们则共享进程的资源，各自拥有自己独立的栈和寄存器（==私有财产==），创建和销毁的开销就非常小     补充知识：栈用来储存变量，函数，地址，寄存器用来执行和工作（工作台）

## 1.3通信机制不同

由于内存隔离，进程间通信（IPC）需要用到==管道，消息队列，共享内存==等复杂机制，而线程因为共享进程的全局变量和堆内存，通信非常简单直接，但是正因如此，必须使用==锁等同步机制==来保证数据安全否则容易产生==竞态条件==。

## 1.4健壮性不同
一个进程崩溃后再保护模式下不会影响其他进程，但是一个进程里的一个线程崩溃，会导致整个进程崩溃，会影响到其他线程



---


## 2 Thread类是什么？有什么用?


（1）本质上是一组操作线程的函数（c语言）
jvm把这个函数封装了，给到程序员就是thread类，使用这类就相当于在使用操作系统的api
（2）Thread的作用就是**对线程进行创建和管理，实现多线程**

补充：这里的继承是为了**拓展**


---

## 3 run方法有啥用?

run方法其实是**线程操作的的入口**，类比于（主线程）main，run里面写的就是要执行的操作

补充：run方法是重写Thread类里的

---

## 4 创建并执行线程的基本步骤

1 创建线程，定义要执行的操作
2 new线程实例
3 调用 .start（）方法（在main中）
```java
public class MyThread extends Thread{  
    @Override  
    public void run() {  
        while (true) {  
            System.out.println("线程任务");  
        }  
    }  
}
```


```java
public class Test {  
    public static void main(String[] args) {  
        Thread thread = new MyThread();  
        thread.start();  
        while (true) {  
            System.out.println("主线程任务");  
        }  
    }  
}
```

==注意⚠️start操作才是真正的开始调用操作系统api来创建一个线程，并以run为入口开始执行，所以单独对Thread调run（）方法没有创建新的线程，而是在主线程里执run==

**效果**

![](assets/2%20多线程/file-20251204205625924.png)

---

## 5 如何让程序休眠（线程等待）?如何处理异常?
```java
thread.sleep（1000）//单位是ms
```
在这个时候通常主线程里需要throw抛出中断异常

创建线程里run方法里由于**父类Thread方法里没有抛出任何异常**所以需要，try catch显示处理掉==（方法声明会冲突，无法构成方法重写）==

如下
```java
public class Test {  
    public static void main(String[] args) throws InterruptedException{   
        Thread thread = new MyThread();  
        thread.start();  
        while (true) {  
            System.out.println("主线程任务");  
            Thread.sleep(1000);  
        }  
    }  
}
```


```java
public class MyThread extends Thread{  
    @Override  
    public void run() {  
        while (true) {  
            System.out.println("线程任务");  
            try {  
                Thread.sleep(1000);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```
---

## 6 归纳创建线程的方法

### 方法一
同上文方法
```java
public class Test {  
    public static class MyThread extends Thread{  
        @Override  
        public void run() {  
            System.out.println("线程任务");  
        }  
    }  
    public static void main(String[] args) {  
        Thread thread = new MyThread();  
        thread.start();  
        System.out.println("主线程任务");  
    }  
}
```

### 方法二

1 实现Runnable接口，重写run方法
2 new runnable实例
3 new Thread实例，并把runnable实例传给实例出的thread
4 调用start
```java
class MyRunnable implements Runnable{  
    @Override  
    public void run() {  
        try {  
            System.out.println("线程任务");  
            Thread.sleep(1000);  
        } catch (InterruptedException e) {  
            throw new RuntimeException(e);  
        }  
    }  
}
```

```java
public class Test {  
    public static void main(String[] args) throws InterruptedException {  
        Runnable runnable = new MyRunnable();  
        Thread thread = new Thread(runnable);  
        thread.start();  
        while (true) {  
            System.out.println("主线程任务");  
            Thread.sleep(1000);  
        }  
    }  
}
```

r让我们重温一下接口，接口是干啥的?==提供一系列抽象方法，让子类重写（规范化）==

### 二者比较

第一种把要执行的任务run（）和创建的线程thread==耦合==
第二种则是单独写要执行的任务，==再交给线程执行==
第一种里的任务再无法给其他主体执行 ，第二种则可以把任务交给，进程乃至协程去执行
协程实际上就是轻量级线程

### 方法三

1 创建匿名内部类
2 子类重写run，同时创建了实例，让t指向该实例
3 调start（）

```java
public class Test2 {  
    public static void main(String[] args) {  
        Thread thread = new Thread(){  
            @Override  
            public void run() {  
                while (true) {  
                    System.out.println("哈哈哈");  
                }  
            }  
        };  
        thread.start();  
        while (true) {  
            System.out.println("666");  
        }  
    }  
}
```

### 方法四

1 写runnable的匿名内部类
2 重写run传给实例化出的thread对象
3 调start（）

```java
public class Test3 {  
    public static void main(String[] args) {  
        Runnable runnable = new Runnable() {  
            @Override  
            public void run() {  
                while (true) {  
                    System.out.println("666");  
                }  
            }  
        };  
        Thread thread = new Thread(runnable);  
        thread.start();  
        while (true) {  
            System.out.println("hhh");  
        }  
    }  
}
```

### 方法五
lambda表达式
Thread括号里写（（）->｛直接写要执行的任务｝），lambda就是执行入口

代码示例


## 7 Thread提供的其他功能

命名
创建线程时
Thread（String name）
代码示例

## 8 什么是前台线程?什么是后台线程?
对于前台线程，这个线程没执行完，进程就不会结束
对于后台线程，这个线程没运行完，进程可以结束，无法阻止进程结束

自己创建的默认是前台线程
如果在start之前也可以通过setDaemon来修改为后台，JVM垃圾回收就是后台线程（周期性执行）
isAilve（）返回true，false，本质上是判断是否在执行