## 1 为什么需要优先级队列?解决了什么问题?
队列中的元素在有些情况下是需要有优先级的，是需要先出队列的，所以就有了优先级队列

## 2 堆是什么?
把元素按照完全二叉树的方式顺序存储在一个一维数组中，的一种数据结构，实际上底层是完全二叉树，只是按照层序遍历完全二叉树的顺序，把元素放到一个一维数组里，所以完全二叉树是堆的逻辑结构，一维数组则是存储结构

## 3 什么是大根堆?什么是小根堆?
大根就是，该堆的底层完全二叉树的根节点是整棵树最大的节点，类比可得小根堆

## 4 需要明确的性质
i是下标
对于父节点有（i-1）/2
对于子节点有2*i+1（左），2*i+2（右）

## 5 堆是怎么创建的
### 5.1堆的成员变量和构造
```java
int[] array;  
int usedSize;  
public static final int DEFAULT_CAPACITY = 10;  
public MyHeap() {  
    array = new int[DEFAULT_CAPACITY];  
}  
//给堆中添加数据  
public void initArray(int[] elem){  
    for(int i = 0; i <elem.length; i++){  
        array[i] = elem[i];  
    }  
}
```

### 5.2向下调整（大根堆）
![](assets/8%20优先级队列（堆）/file-20251203204849448.png)
如图所示，对于11而言就是我们需要向下调整的对象，因为在11，43，46，组成的子树里11不是最大的，所以就需要我们进行向下调整

### 5.3 调整思路
1. 设置一个child方便比较和调整位置
2. 明确每一步需要干什么，对于向下调整大根堆而言，首先就是要和子结点比较
3. 子节点之间也需要比较，挑选更小的一个作为child
4. 明确，父结点和子结点的大小关系，如果父结点是较小的对象就需要交换二者
5. 更新父结点，原子结点成为父结点，重新设置子结点
6. 设置循环结束条件，实际上就是子结点的索引的值小于usedSize 
7. ![](assets/8%20优先级队列（堆）/file-20251203204849445.png)


```java
private void siftDown(int parent, int usedSize){  
    int child = parent*2+1;  
    while (child < usedSize) {  
        if(child+1 < usedSize && array[child] < array[child+1]){  
            child++;  
        }  
        if(array[child] > array[parent]){  
            swap(child,parent);  
            parent = child;  
            child = parent*2+1;  
        }else {  
            break;  
        }  
    }  
}
```

### 5.4 向下调整建堆

```java
public void createHeap(){  
    for(int parent = (usedSize-1-1)/2; parent >= 0; parent--){  
        siftDown(parent,usedSize);  
    }  
} //时间复杂度O（n）
```

这里的思路其实就是保证parent从最后一个子树的根结点一直到下标为0的结点每一一个都经历向下调整，保证建的是一个大根堆
### 5.5 向上调整

向上调整一般都是从底部开始
![](assets/8%20优先级队列（堆）/file-20251203204849443.png)
### 5.6 调整思路
1. 设置parent便于比较
2. 与父结点比较，交换
3. 设置循环终止条件，child>0
```java
private void siftUp(int child){  
    int parent = (child-1)/2;  
    while (child>0) {  
        if(array[parent] < array[child]){  
            swap(parent,child);  
            child = parent;//先挪动原来parent的位置  
            parent = (child-1)/2;//在更新parent的值  
        }else {  
            break;  
        }  
    }  
}
```


### 5.7 poll,peek方法实现
poll方法
思路
1. 判空
2. 交换堆顶和最后一个元素
3. 删除该元素
4. 向下调整
```java
//优先队列出队——队顶  
public int poll(){  
    if (isEmpty()){  
        throw new heapEmptyException("队列为空,不合法的出队");  
    }  
    int val = array[0];  
    swap(0,usedSize-1);  
    usedSize--;  
    siftDown(0,usedSize);  
    return val;  
}
```
peek方法

```java
//取队头  
public int peek(){  
    if (isEmpty()){  
        throw new heapEmptyException("队列为空");  
    }  
    return array[0];  
}
```
## 6 堆排序
堆排序实现思路
1. 每次让堆顶元素和末尾元素换（堆顶元素最大（大堆））
2. jioa

```java
public void heapSort(){  
    int end = usedSize-1;  
    swap(0,end);  
    siftDown(0,end);  
    end--;  
}
```